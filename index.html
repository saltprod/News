<!doctype html>
<html lang="ru">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Telegram MiniApp - –ú–æ—è –ª–µ–Ω—Ç–∞</title>
  <style>
    :root {
      --bg: #0b1226;
      --surface: #0e1730;
      --surface-2: #101c38;
      --text: #eef2ff;
      --secondary: #101c38;
      --muted: #9fb0d0;
      --accent: #ff8a3d;
      --accent-2: #4cc9f0;
      --accent-rgb: 255, 138, 61;
      --border: rgba(255, 255, 255, 0.06);
      --pill-bg: rgba(255, 255, 255, 0.06);
      --btn-alpha: 0.16;
      --radius: 14px;
      --shadow: 0 16px 40px rgba(2, 8, 20, 0.45);
      --header-h: 168px;
      --bottom-h: 64px;
      --tg-safe-top: env(safe-area-inset-top);
      --tg-safe-bottom: env(safe-area-inset-bottom);
      --tg-topbar: 0px;
      --safe-top: var(--tg-safe-top);
      --safe-bottom: var(--tg-safe-bottom);
      --app-h: 100%;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: "Space Grotesk", "IBM Plex Sans", "Segoe UI", sans-serif
    }

    body {
      background:
        radial-gradient(900px 520px at 10% -10%, rgba(255, 138, 61, 0.18), transparent 60%),
        radial-gradient(720px 400px at 90% 10%, rgba(76, 201, 240, 0.18), transparent 60%),
        linear-gradient(180deg, #080f22 0%, #0b1226 45%, #0b1226 100%);
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      height: var(--app-h);
    }


    canvas#snowCanvas {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      z-index: 0;
      pointer-events: none;
      opacity: 0.15
    }

    body.bg-on canvas#snowCanvas {
      opacity: 0.55
    }

    .app {
      position: relative;
      z-index: 2;
      max-width: 1024px;
      margin: 0 auto;
      padding-bottom: 0
    }

    .tg-webapp .app {
      padding-top: calc(env(safe-area-inset-top) + 56px)
    }

    /* make header fixed so it stays visible in Telegram WebView */
    header {
      position: sticky;
      top: 0;
      z-index: 50;
      background: transparent;
    }

    header::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: -100px;
      /* ‚Üê –ø–æ–¥–Ω–∏–º–∏ –∑–∞–ª–∏–≤–∫—É –≤—ã—à–µ –∫–Ω–æ–ø–æ–∫ */
      bottom: -10px;
      background: rgba(10, 14, 24, 0.35);
      backdrop-filter: blur(14px) saturate(120%);
      -webkit-backdrop-filter: blur(14px) saturate(120%);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      z-index: -1;
      /* —Ñ–æ–Ω –ø–æ–¥ –∫–Ω–æ–ø–∫–∞–º–∏ */
    }

    main {
      height: calc(var(--app-h) - var(--header-h) - var(--bottom-h));
      overflow: auto;
      padding: 12px 18px calc(16px + env(safe-area-inset-bottom));
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain
    }

    .hdrRow {
      display: grid;
      grid-template-columns: 1fr 30px 30px;
      align-items: center;
      column-gap: 10px;
      width: 100%;
      background: transparent
    }

    .header-title {
      display: none
    }

    .title-row {
      display: flex;
      align-items: center;
      gap: 12px
    }

    .iconBtn {
      width: 30px;
      height: 30px;
      padding: 0;
      font-size: 15px;
      line-height: 30px;
      border-radius: 12px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.08)
    }

    .iconBtn:hover,
    .iconBtn:active {
      background: rgba(255, 255, 255, 0.1)
    }

    .iconBtn.active {
      background: rgba(var(--accent-rgb), 0.2);
      border: 1px solid rgba(var(--accent-rgb), 0.35)
    }

    .source-btn,
    .source-select.compact {
      min-width: 0;
      width: 100%;
      max-width: 220px;
      height: 30px;
      font-size: 12px;
      padding: 0 24px 0 10px;
      border-radius: 12px;
      appearance: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background-image:
        linear-gradient(45deg, transparent 50%, rgba(255, 255, 255, 0.5) 50%),
        linear-gradient(135deg, rgba(255, 255, 255, 0.5) 50%, transparent 50%);
      background-position: calc(100% - 14px) 12px, calc(100% - 9px) 12px;
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat
    }

    .source-btn {
      text-align: left;
      cursor: pointer;
      line-height: 30px
    }

    .source-select.source-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none
    }

    .menu-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.32);
      z-index: 80;
      display: none
    }

    .menu-popover {
      position: fixed;
      z-index: 90;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      min-width: 200px;
      box-shadow: var(--shadow);
      display: none
    }

    .menu-popover .menu-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 6px 4px
    }

    .menu-popover .menu-label {
      font-size: 12px;
      color: var(--muted)
    }

    .source-menu-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.35);
      z-index: 85;
      display: none
    }

    .source-menu {
      position: fixed;
      z-index: 96;
      background: rgba(10, 14, 24, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      padding: 8px;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
      max-height: 55vh;
      overflow: auto;
      display: none;
      backdrop-filter: blur(14px) saturate(120%);
      -webkit-backdrop-filter: blur(14px) saturate(120%)
    }

    .source-item {
      width: 100%;
      text-align: left;
      padding: 8px 10px;
      background: transparent;
      border: 0;
      color: var(--text);
      font-size: 12px;
      border-radius: 10px;
      cursor: pointer
    }

    .source-item.active {
      background: rgba(255, 255, 255, 0.08)
    }
    .tg-webapp .modal-actions .tg-hide {
      display: none
    }

    h1 {
      font-size: 20px;
      margin: 0;
      letter-spacing: 0.2px
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px
    }

    .title-actions {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .logo {
      width: 34px;
      height: 34px;
      border-radius: 12px;
      background: linear-gradient(140deg, var(--accent), var(--accent-2));
      display: grid;
      place-items: center;
      color: #081022;
      font-weight: 700
    }

    .user {
      color: var(--muted);
      font-size: 13px;
      margin-top: 4px
    }

    .toolbar {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 12px
    }

    .search-wrap {
      flex: 1;
      min-width: 180px;
      display: flex;
      gap: 8px
    }

    .input,
    .source-select {
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      padding: 10px 12px;
      border-radius: 10px;
      font-size: 14px;
      outline: none
    }

    .input::placeholder {
      color: #7686a6
    }

    .source-select {
      min-width: 160px
    }

    .chip {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      padding: 9px 12px;
      border-radius: 999px;
      font-size: 13px;
      cursor: pointer
    }

    .chip.active {
      background: rgba(var(--accent-rgb), 0.18);
      border-color: rgba(var(--accent-rgb), 0.4)
    }

    .stats {
      display: none;
      background: transparent
    }

    .stat-pill {
      background: var(--pill-bg);
      border: 1px solid var(--border);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted)
    }

    .status-pill {
      background: rgba(76, 201, 240, 0.14);
      border: 1px solid rgba(76, 201, 240, 0.32);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      color: #bdeaf7;
      opacity: 0;
      transition: opacity .2s
    }

    .status-pill.show {
      opacity: 1
    }

    .panel {
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px;
      box-shadow: var(--shadow)
    }

    .news-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 12px
    }

    .card {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.035), rgba(255, 255, 255, 0.01));
      border-radius: var(--radius);
      padding: 14px;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.06);
      transition: transform .12s ease, border-color .2s ease
    }

    .card:hover {
      transform: translateY(-2px);
      border-color: rgba(255, 138, 61, 0.35)
    }

    .card h4 {
      margin: 0 0 6px 0;
      font-size: 15px;
      line-height: 1.3
    }

    .card {
      content-visibility: auto;
      contain-intrinsic-size: 120px;
      contain: content
    }

    .card p {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.45
    }

    .desc {
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden
    }

    .meta {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      align-items: center
    }

    .meta-left {
      display: flex;
      align-items: center;
      gap: 8px
    }

    .tag {
      background: rgba(255, 255, 255, 0.06);
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 11px;
      color: var(--muted)
    }

    .time {
      color: #8da1c7
    }

    /* fixed bottom bar */
    .bottom-bar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(180deg, rgba(12, 20, 40, 0.92), rgba(12, 20, 40, 0.98));
      padding: 10px 12px;
      padding-bottom: calc(10px + env(safe-area-inset-bottom));
      display: flex;
      justify-content: center;
      gap: 10px;
      z-index: 50;
      border-top: 1px solid var(--border)
    }

    .btn {
      background: rgba(var(--accent-rgb), var(--btn-alpha));
      border: 0;
      padding: 9px 12px;
      border-radius: 10px;
      color: var(--text);
      cursor: pointer;
      transition: transform .1s ease
    }

    .btn:active {
      transform: scale(0.98)
    }

    .btn.ghost {
      background: transparent;
      border: 1px solid var(--border)
    }

    .btn.small {
      padding: 8px 10px;
      font-size: 12px
    }

    .modal-backdrop {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.45);
      z-index: 6
    }

    .modal {
      background: var(--surface);
      padding: 18px;
      border-radius: 16px;
      max-width: 820px;
      width: 94%;
      max-height: calc(var(--app-h) * 0.92);
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
      color: var(--text);
      position: relative;
      display: flex;
      flex-direction: column
    }

    .modal .close {
      position: absolute;
      right: 18px;
      top: 18px;
      background: transparent;
      border: 0;
      color: var(--muted);
      cursor: pointer;
      font-size: 22px;
      line-height: 1
    }

    .modal-body {
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      max-height: calc(var(--app-h) * 0.92 - 120px);
      overscroll-behavior: contain
    }
    .detail-text {
      white-space: pre-wrap;
      overflow: auto;
      display: block;
      line-height: 1.45
    }

    .modal-actions {
      position: sticky;
      bottom: 0;
      background: var(--surface);
      padding-top: 10px;
      padding-bottom: calc(8px + var(--safe-bottom));
      margin-top: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: nowrap;
      overflow-x: auto;
      border-top: 1px solid var(--border)
    }

    .btn.compact {
      padding: 6px 10px;
      font-size: 12px;
      min-height: 44px
    }

    .lang-select.compact {
      padding: 6px 8px;
      font-size: 12px;
      min-height: 44px
    }

    .translate-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 12px;
      flex-wrap: wrap
    }

    .translate-output {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid var(--border);
      color: var(--text);
      font-size: 13px
    }

    .lang-select {
      background: var(--surface);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      font-size: 12px
    }

    .toggle {
      width: 44px;
      height: 26px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      padding: 4px;
      cursor: pointer;
      border: 1px solid var(--border)
    }

    .toggle.on {
      background: rgba(var(--accent-rgb), 0.28)
    }

    .toggle .dot {
      width: 18px;
      height: 18px;
      background: white;
      border-radius: 50%;
      transform: translateX(0);
      transition: transform .18s
    }

    .toggle.on .dot {
      transform: translateX(16px)
    }

    .badge {
      background: rgba(255, 255, 255, 0.04);
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted)
    }

    .bg-toggle-wrap {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .feed-advanced {
      margin-top: 12px;
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 10px;
      box-shadow: var(--shadow);
      display: none;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap
    }

    .feed-advanced.show {
      display: flex
    }

    .feed-advanced .input,
    .feed-advanced .btn {
      min-height: 36px;
      font-size: 12px;
      padding: 6px 10px
    }

    .skeleton {
      height: 14px;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
      border-radius: 6px;
      animation: shimmer 1.3s infinite;
      background-size: 200px 100%
    }

    .empty {
      padding: 30px 16px;
      text-align: center;
      color: var(--muted)
    }

    .status-pill.error {
      background: rgba(255, 120, 120, 0.16);
      border-color: rgba(255, 120, 120, 0.35);
      color: #ffd0d0
    }

    a {
      color: inherit
    }

    @keyframes shimmer {
      0% {
        background-position: -120px 0
      }

      100% {
        background-position: 120px 0
      }
    }

    @media (max-width:720px) {
      :root {
        --header-h: 188px
      }

      .bottom-bar {
        padding: 8px
      }
    }

    @media (max-width:520px) {
      :root {
        --header-h: 100px
      }

      header {
        padding: calc(env(safe-area-inset-top) + 24px) 12px 6px
      }
      .hdrRow {
        padding: 8px 12px 10px
      }

      .header-top {
        align-items: center
      }

      h1 {
        font-size: 14px
      }

      .user {
        font-size: 11px;
        opacity: 0.8
      }

      .stats {
        gap: 6px
      }

      .stat-pill,
      .status-pill {
        font-size: 10px;
        padding: 4px 6px;
        white-space: nowrap
      }

      .source-select {
        min-height: 36px;
        padding: 4px 8px
      }

      .btn,
      .source-select,
      .input {
        min-height: 44px
      }

      .bg-toggle-wrap {
        min-height: 44px
      }

      .toggle {
        width: 38px;
        height: 22px;
        padding: 3px
      }

      .toggle .dot {
        width: 14px;
        height: 14px
      }

      .iconBtn {
        width: 28px;
        height: 28px;
        font-size: 14px;
        border-radius: 11px
      }

      .hdrRow {
        column-gap: 8px
      }

      .source-select.compact {
        max-width: 180px
      }

      .feed-advanced {
        padding: 8px
      }

    }
  </style>
</head>

<body>
  <canvas id="snowCanvas"></canvas>
  <div class="app" id="app">
    <header>
      <div class="hdrRow">
        <button id="sourceBtn" class="source-btn" aria-haspopup="true" aria-expanded="false">–ò—Å—Ç–æ—á–Ω–∏–∫: ...</button>
        <button id="btnFavFilter" class="btn ghost iconBtn" aria-pressed="false" aria-label="–ò–∑–±—Ä–∞–Ω–Ω—ã–µ">‚≠ê</button>
        <button id="btnMenu" class="btn ghost iconBtn" aria-label="–ú–µ–Ω—é">‚ãØ</button>
      </div>
      <select id="sourceSelect" class="source-select compact source-hidden" aria-hidden="true" tabindex="-1"></select>
    </header>
    <main>
      <div id="feedAdvanced" class="feed-advanced">
        <input id="inputFeed" class="input"
          placeholder="rss:https://example.com/feed.xml –∏–ª–∏ https://api.example.com/news.json" />
        <button id="btnLoad" class="btn">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
      </div>
      <div id="news" class="news-list"></div>
      <div id="emptyState" class="empty" style="display:none">–ü–æ–∫–∞ –Ω–∏—á–µ–≥–æ –Ω–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∏–ª–∏
        –∏–∑–º–µ–Ω–∏—Ç—å –ø–æ–∏—Å–∫.</div>
    </main>

    <div class="bottom-bar">
      <button id="btnLoadMore" class="btn">–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â–µ</button>
    </div>
  </div>

  <template id="cardTpl">
    <div class="card">
      <h4 class="ttl"></h4>
      <p class="desc"></p>
      <div class="meta">
        <div class="meta-left">
          <div class="source tag"></div>
          <div class="time"></div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <!-- translation badge removed -->
          <button class="btn btnFav">‚òÜ</button>
        </div>
      </div>
    </div>
  </template>

  <div id="modalRoot" style="display:none"></div>
  <div id="menuBackdrop" class="menu-backdrop"></div>
  <div id="menuPopover" class="menu-popover" role="menu" aria-hidden="true">
    <div class="menu-row">
      <span id="bgLabel" class="badge">–§–æ–Ω: –í—ã–∫–ª</span>
      <button id="bgToggle" class="toggle" aria-label="–ê–Ω–∏–º–∞—Ü–∏—è —Ñ–æ–Ω–∞"><span class="dot"></span></button>
    </div>
    <div class="menu-row">
      <span class="menu-label">RSS —Å—Ç—Ä–æ–∫–∞</span>
      <button id="btnToggleAdvanced" class="btn ghost small" aria-pressed="false">–°–∫—Ä—ã—Ç–∞</button>
    </div>
  </div>
  <div id="sourceMenuBackdrop" class="source-menu-backdrop"></div>
  <div id="sourceMenu" class="source-menu" role="menu" aria-hidden="true"></div>

  <script>
    // Minimal Telegram.WebApp shim for local testing
    window.Telegram = window.Telegram || { WebApp: { initData: null, initDataUnsafe: {}, platform: 'web' } };

    // LocalStorage keys
    const LS_FAV = 'tg_minapp_fav_v1';
    const LS_LAST = 'tg_minapp_last_v1';
    const LS_BG = 'tg_minapp_bg_anim_v1';
    const LS_THEME = 'tg_minapp_theme_override';
    const LS_TRANSLATIONS = 'tg_translations_v1';
    const API_BASE = 'https://hidden-silence-1ec8.ilyxich4.workers.dev';
    const API_BASE_N = API_BASE.replace(/\/+$/, '');
    const RSS_ENDPOINT = API_BASE_N + '/rss';
    const TRANSLATE_ENDPOINT = API_BASE_N + '/translate';
    const LS_UI_ADVANCED = 'tg_minapp_ui_advanced';

    // Config: change to your feed. Supports 'rss:<URL>' or 'https://.../json'
    let fetchUrl = 'rss:https://rss.nytimes.com/services/xml/rss/nyt/World.xml';

    // Selected source storage
    const LS_SRC = 'tg_minapp_src_v1';

    // Available sources (id, name, url). URLs are prefixed with 'rss:' when they are RSS feeds.
    const SOURCES = [
      { id: 'bbc', name: 'BBC News', url: 'rss:https://feeds.bbci.co.uk/news/rss.xml' },
      { id: 'cnn', name: 'CNN', url: 'rss:http://rss.cnn.com/rss/edition.rss' },
      { id: 'guardian', name: 'The Guardian', url: 'rss:https://www.theguardian.com/world/rss' },
      { id: 'aljazeera', name: 'Al Jazeera', url: 'rss:https://www.aljazeera.com/xml/rss/all.xml' },
      { id: 'bloomberg', name: 'Bloomberg', url: 'rss:https://www.bloomberg.com/feed/podcast/etf.xml' },
      { id: 'techcrunch', name: 'TechCrunch', url: 'rss:https://techcrunch.com/feed/' },
      { id: 'verge', name: 'The Verge', url: 'rss:https://www.theverge.com/rss/index.xml' },
      { id: 'hn', name: 'Hacker News', url: 'rss:https://hnrss.org/frontpage' },
      { id: 'coindesk', name: 'CoinDesk', url: 'rss:https://www.coindesk.com/arc/outboundfeeds/rss/' },
      { id: 'cointelegraph', name: 'CoinTelegraph', url: 'rss:https://cointelegraph.com/rss' },
      { id: 'ft', name: 'Financial Times', url: 'rss:https://www.ft.com/?format=rss' },
      { id: 'nytimes', name: 'The New York Times', url: 'rss:https://rss.nytimes.com/services/xml/rss/nyt/World.xml' },
      { id: 'ap', name: 'Associated Press', url: 'rss:https://apnews.com/hub/ap-top-news?outputType=RSS' },
      { id: 'npr', name: 'NPR', url: 'rss:https://feeds.npr.org/1001/rss.xml' },
      { id: 'wired', name: 'Wired', url: 'rss:https://www.wired.com/feed/rss' },
      { id: 'arstechnica', name: 'Ars Technica', url: 'rss:http://feeds.arstechnica.com/arstechnica/index' },
      { id: 'engadget', name: 'Engadget', url: 'rss:https://www.engadget.com/rss.xml' },
      { id: 'euronews', name: 'Euronews', url: 'rss:https://www.euronews.com/rss?level=2&name=home' },
      { id: 'dw', name: 'DW', url: 'rss:https://rss.dw.com/rdf/rss-en-all' },
      { id: 'guardian-tech', name: 'The Guardian - Tech', url: 'rss:https://www.theguardian.com/uk/technology/rss' },
      { id: 'techmcr', name: 'Techmeme', url: 'rss:https://www.techmeme.com/feed.xml' },
      { id: 'eng', name: 'Engage (examples)', url: 'rss:https://feeds.feedburner.com/TechCrunch/' },
      { id: 'bbc-world', name: 'BBC World', url: 'rss:https://feeds.bbci.co.uk/news/world/rss.xml' }
    ];

    function updateSourceButton(id) {
      const btn = document.getElementById('sourceBtn');
      const src = SOURCES.find(s => s.id === id);
      if (btn) btn.textContent = `–ò—Å—Ç–æ—á–Ω–∏–∫: ${src ? src.name : '...'}`;
    }
    function updateSourceMenuActive(id) {
      const items = document.querySelectorAll('#sourceMenu .source-item');
      items.forEach(it => {
        it.classList.toggle('active', it.dataset.id === id);
      });
    }
    function buildSourceMenu() {
      const menu = document.getElementById('sourceMenu');
      if (!menu) return;
      menu.innerHTML = '';
      SOURCES.forEach(s => {
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'source-item';
        item.dataset.id = s.id;
        item.textContent = s.name;
        item.addEventListener('click', () => {
          closeSourceMenu();
          setSourceById(s.id);
        });
        menu.appendChild(item);
      });
    }
    function positionSourceMenu() {
      const btn = document.getElementById('sourceBtn');
      const menu = document.getElementById('sourceMenu');
      if (!btn || !menu) return;
      const rect = btn.getBoundingClientRect();
      const pad = 8;
      const maxH = Math.min(window.innerHeight * 0.55, 420);
      menu.style.maxHeight = `${maxH}px`;
      const width = menu.offsetWidth || 240;
      let left = rect.left;
      if (left + width > window.innerWidth - pad) left = window.innerWidth - width - pad;
      let top = rect.bottom + pad;
      if (top + menu.offsetHeight > window.innerHeight - pad) top = rect.top - menu.offsetHeight - pad;
      if (top < pad) top = pad;
      menu.style.left = `${left}px`;
      menu.style.top = `${top}px`;
    }
    function openSourceMenu() {
      const btn = document.getElementById('sourceBtn');
      const menu = document.getElementById('sourceMenu');
      const backdrop = document.getElementById('sourceMenuBackdrop');
      if (!btn || !menu || !backdrop) return;
      const isOpen = menu.style.display === 'block';
      if (isOpen) { closeSourceMenu(); return; }
      menu.style.display = 'block';
      menu.setAttribute('aria-hidden', 'false');
      backdrop.style.display = 'block';
      positionSourceMenu();
      const saved = localStorage.getItem(LS_SRC);
      updateSourceMenuActive(saved);
      btn.setAttribute('aria-expanded', 'true');
    }
    function closeSourceMenu() {
      const menu = document.getElementById('sourceMenu');
      const backdrop = document.getElementById('sourceMenuBackdrop');
      const btn = document.getElementById('sourceBtn');
      if (menu) { menu.style.display = 'none'; menu.setAttribute('aria-hidden', 'true'); }
      if (backdrop) backdrop.style.display = 'none';
      if (btn) btn.setAttribute('aria-expanded', 'false');
    }
    function setSourceById(id) {
      const sel = document.getElementById('sourceSelect');
      if (sel) sel.value = id;
      updateSourceButton(id);
      updateSourceMenuActive(id);
      if (id) loadNewsById(id);
    }

    // Populate the source selector and wire persistence
    function loadSources() {
      const sel = document.getElementById('sourceSelect'); if (!sel) return;
      sel.innerHTML = '';
      const placeholder = document.createElement('option'); placeholder.value = ''; placeholder.textContent = '–í—ã–±–µ—Ä–∏—Ç–µ –∏—Å—Ç–æ—á–Ω–∏–∫...'; sel.appendChild(placeholder);
      SOURCES.forEach(s => { const o = document.createElement('option'); o.value = s.id; o.textContent = s.name; sel.appendChild(o); });
      // restore selection
      const saved = localStorage.getItem(LS_SRC);
      if (saved) { sel.value = saved; const src = SOURCES.find(x => x.id === saved); if (src) { fetchUrl = src.url; document.getElementById('inputFeed').value = fetchUrl; } }
      updateSourceButton(saved || '');
      buildSourceMenu();
      sel.addEventListener('change', (e) => {
        const id = e.target.value; if (!id) return;
        setSourceById(id);
      });
      // selection change already triggers load; no top reload button present
    }

    // Load news by source id (modular entrypoint)
    function loadNewsById(sourceId) {
      const src = SOURCES.find(s => s.id === sourceId);
      if (!src) { setStatus('–ò—Å—Ç–æ—á–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω'); return; }
      try { localStorage.setItem(LS_SRC, sourceId); fetchUrl = src.url; document.getElementById('inputFeed').value = fetchUrl; news = []; displayedCount = PAGE_SIZE; renderNews(); loadNews(src.url); }
      catch (e) { console.error('loadNewsById', e); setStatus('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∞'); }
    }

    // Small mock fallback
    const BASE_NEWS = [{ id: 'm1', title: '–ü—Ä–∏–º–µ—Ä –Ω–æ–≤–æ—Å—Ç–∏', summary: '–ö–æ—Ä–æ—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ', link: '#', source: '–ü—Ä–∏–º–µ—Ä', date: new Date().toISOString() }];

    let news = [];
    let isLoading = false;
    let favs = new Set(JSON.parse(localStorage.getItem(LS_FAV) || '[]'));
    let favFilterOn = false;
    // pagination / UI state
    const PAGE_SIZE = 10;
    let displayedCount = 0; // how many items currently rendered

    const $ = (sel, root = document) => root.querySelector(sel);
    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

    // Utilities
    function saveFavs() { localStorage.setItem(LS_FAV, JSON.stringify(Array.from(favs))); }
    // lightweight status: log + show status pill
    function setStatus(text, isError = false) {
      try {
        const pill = document.getElementById('statusPill');
        if (pill) {
          pill.textContent = text;
          pill.classList.toggle('error', !!isError);
          pill.classList.add('show');
          clearTimeout(pill._hideTimer);
          pill._hideTimer = setTimeout(() => pill.classList.remove('show'), isError ? 3600 : 2200);
        }
      } catch (e) { }
      console.log('[status]', text);
    }

    // Fetch helpers
    async function fetchWithTimeout(url, opts = {}, ms = 12000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), ms);
      try { const res = await fetch(url, { ...opts, signal: controller.signal }); clearTimeout(id); return res; } catch (e) { clearTimeout(id); throw e; }
    }

    async function fetchRssViaAllOrigins(rssUrl) {
      const apiUrl = `${RSS_ENDPOINT}?url=${encodeURIComponent(rssUrl)}`;
      setStatus('RSS: worker (loading)');
      const res = await fetchWithTimeout(apiUrl, {}, 20000);
      if (!res.ok) {
        console.warn('RSS worker non-OK', { apiUrl, rssUrl, status: res.status });
        setStatus(`RSS: worker (HTTP ${res.status})`, true);
        throw new Error(`RSS: worker HTTP ${res.status}`);
      }
      const data = await res.json();
      if (!data || !Array.isArray(data.items)) {
        console.warn('RSS worker invalid', { apiUrl, rssUrl, data });
        setStatus('RSS: worker (invalid)', true);
        throw new Error('RSS: worker invalid');
      }
      setStatus('RSS: worker OK');
      return data.items.map((it, i) => ({
        id: it.id || it.guid || 'rss-' + i,
        title: it.title || it.name || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è',
        summary: it.summary || it.description || it.excerpt || '',
        description: it.description || '',
        content: it.content || it['content:encoded'] || it.content_encoded || it.encoded || '',
        link: it.link || it.url || '#',
        source: it.source || it.feed || 'RSS',
        date: it.date || it.pubDate || it.published || ''
      }));
    }

    async function loadNews(url) {
      isLoading = true; renderNews();
      setStatus('–ó–∞–≥—Ä—É–∑–∫–∞...');
      let items = [];
      try {
        if (!url) url = fetchUrl;
        if (url.startsWith('rss:')) {
          const r = url.slice(4);
          items = await fetchRssViaAllOrigins(r);
        } else {
          const res = await fetchWithTimeout(url, {}, 12000);
          if (!res.ok) {
            console.error('JSON non-OK', { url, status: res.status });
            throw new Error('JSON: HTTP ' + res.status);
          }
          const obj = await res.json();
          if (Array.isArray(obj)) items = obj;
          else if (obj && typeof obj === 'object') {
            items = obj.items || obj.articles || obj.data || obj.results || [];
          }
          if (!Array.isArray(items)) {
            console.error('JSON invalid shape', { url, obj });
            throw new Error('JSON: –Ω–µ –Ω–∞–π–¥–µ–Ω –º–∞—Å—Å–∏–≤ items');
          }
          items = items.map((it, i) => ({
            id: it.id || it.guid || 'j-' + i,
            title: it.title || it.name || '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è',
            summary: it.summary || it.description || it.excerpt || '',
            description: it.description || '',
            content: it.content || it['content:encoded'] || it.content_encoded || it.encoded || '',
            link: it.url || it.link || '#',
            source: it.source || it.feed || 'JSON',
            date: it.date || it.published_at || it.pubDate || it.time || ''
          }));
        }
        news = items.length ? items : BASE_NEWS;
        // reset pagination
        displayedCount = Math.min(PAGE_SIZE, getFilteredNews().length);
        localStorage.setItem(LS_LAST, JSON.stringify(news));
        setStatus('–ì–æ—Ç–æ–≤–æ');
      } catch (err) {
        console.error('loadNews', { err, url });
        const cached = JSON.parse(localStorage.getItem(LS_LAST) || 'null');
        news = cached && cached.length ? cached : BASE_NEWS;
        displayedCount = Math.min(PAGE_SIZE, getFilteredNews().length);
        const msg = err && err.message ? err.message : '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏';
        setStatus(msg + '. –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏, –ø–æ–∫–∞–∑–∞–Ω –∫—ç—à', true);
      } finally {
        isLoading = false; renderNews();
      }
    }

    function openExternalLink(url) {
      if (!url) return;
      const tg = window.Telegram && Telegram.WebApp ? Telegram.WebApp : null;
      const isTelegram = /^tg:/.test(url) || /\/\/t\.me\//i.test(url);
      if (tg && isTelegram && typeof tg.openTelegramLink === 'function') {
        tg.openTelegramLink(url);
        return;
      }
      if (tg && typeof tg.openLink === 'function') {
        tg.openLink(url, { try_instant_view: true });
        return;
      }
      window.open(url, '_blank');
    }
    // Render
    function normalizeText(s) { return (s || '').toLowerCase(); }
    function getFilteredNews() {
      const q = '';
      let list = news;
      if (favFilterOn) list = list.filter(it => favs.has(it.id));
      if (q) list = list.filter(it => {
        const title = normalizeText(it.title);
        const desc = normalizeText(it.summary);
        return title.includes(q) || desc.includes(q);
      });
      return list;
    }
    function formatTime(d) {
      if (!d) return '';
      const dt = new Date(d);
      if (Number.isNaN(dt.getTime())) {
        const parsed = Date.parse(d);
        if (Number.isNaN(parsed)) return '';
        return formatTime(new Date(parsed));
      }
      const now = new Date();
      const diff = Math.floor((now - dt) / 60000);
      if (diff < 60) return diff <= 1 ? '—Ç–æ–ª—å–∫–æ —á—Ç–æ' : `${diff} –º–∏–Ω –Ω–∞–∑–∞–¥`;
      const hours = Math.floor(diff / 60);
      if (hours < 24) return `${hours} —á –Ω–∞–∑–∞–¥`;
      return dt.toLocaleDateString('ru-RU', { day: '2-digit', month: 'short' });
    }
    function updateStats(list) {
      const total = news.length || 0;
      const shown = list.length || 0;
      const srcId = localStorage.getItem(LS_SRC);
      const src = SOURCES.find(s => s.id === srcId);
      const countEl = document.getElementById('statCount');
      const srcEl = document.getElementById('statSource');
      if (countEl) countEl.textContent = `${shown} –∏–∑ ${total} –Ω–æ–≤–æ—Å—Ç–µ–π`;
      if (srcEl) srcEl.textContent = `–ò—Å—Ç–æ—á–Ω–∏–∫: ${src ? src.name : '—Ä—É—á–Ω–æ–π'}`;
    }
    function renderNews() {
      const root = $('#news'); root.innerHTML = '';
      if (isLoading) {
        for (let i = 0; i < 4; i++) {
          const s = document.createElement('div'); s.className = 'card'; s.innerHTML = '<div class="skeleton" style="width:60%"></div><div style="height:8px"></div><div class="skeleton" style="width:90%"></div>'; root.appendChild(s);
        }
        return;
      }
      // render only up to displayedCount for 'Load more' pagination
      const filtered = getFilteredNews();
      const list = filtered.slice(0, displayedCount);
      updateStats(filtered);
      const empty = document.getElementById('emptyState');
      if (empty) empty.style.display = list.length ? 'none' : 'block';
      const frag = document.createDocumentFragment();
      list.forEach((it, idx) => {
        const tpl = document.getElementById('cardTpl');
        const node = tpl.content.firstElementChild.cloneNode(true);
        node.querySelector('.ttl').textContent = it.title;
        node.querySelector('.desc').textContent = extractDetailText(it);
        node.querySelector('.source').textContent = it.source || '';
        node.querySelector('.time').textContent = formatTime(it.date);
        const favBtn = node.querySelector('.btnFav');
        favBtn.textContent = favs.has(it.id) ? '‚òÖ' : '‚òÜ';
        favBtn.addEventListener('click', (ev) => { ev.stopPropagation(); toggleFav(it.id); favBtn.textContent = favs.has(it.id) ? '‚òÖ' : '‚òÜ'; renderNews(); });
        node.addEventListener('click', (ev) => { if (ev.ctrlKey || ev.metaKey) { openExternalLink(it.link); } else openDetail(it, idx, list); });
        frag.appendChild(node);
      });
      root.appendChild(frag);
      // toggle Load more button
      const moreBtn = document.getElementById('btnLoadMore');
      if (moreBtn) {
        const hasMore = displayedCount < filtered.length;
        moreBtn.disabled = !hasMore;
        moreBtn.style.display = hasMore ? 'block' : 'none';
        if (hasMore) moreBtn.textContent = '–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â–µ';
      }
    }

    // Modal
    let tgBackHandler = null;
    let tgMainHandler = null;
    let currentTranslateController = null;
    let currentTranslateKey = null;
    function setTelegramBackButton(visible) {
      const tg = window.Telegram && Telegram.WebApp ? Telegram.WebApp : null;
      if (!tg || !tg.BackButton) return;
      if (visible) {
        if (tgBackHandler && typeof tg.BackButton.offClick === 'function') tg.BackButton.offClick(tgBackHandler);
        tgBackHandler = () => closeDetail();
        if (typeof tg.BackButton.onClick === 'function') tg.BackButton.onClick(tgBackHandler);
        if (typeof tg.BackButton.show === 'function') tg.BackButton.show();
      } else {
        if (tgBackHandler && typeof tg.BackButton.offClick === 'function') tg.BackButton.offClick(tgBackHandler);
        if (typeof tg.BackButton.hide === 'function') tg.BackButton.hide();
      }
    }
    function setTelegramMainButton(text, handler) {
      const tg = window.Telegram && Telegram.WebApp ? Telegram.WebApp : null;
      if (!tg || !tg.MainButton) return false;
      if (tgMainHandler && typeof tg.MainButton.offClick === 'function') tg.MainButton.offClick(tgMainHandler);
      tgMainHandler = handler;
      if (typeof tg.MainButton.setText === 'function') tg.MainButton.setText(text);
      if (typeof tg.MainButton.onClick === 'function') tg.MainButton.onClick(tgMainHandler);
      if (typeof tg.MainButton.show === 'function') tg.MainButton.show();
      return true;
    }
    function hideTelegramMainButton() {
      const tg = window.Telegram && Telegram.WebApp ? Telegram.WebApp : null;
      if (!tg || !tg.MainButton) return;
      if (tgMainHandler && typeof tg.MainButton.offClick === 'function') tg.MainButton.offClick(tgMainHandler);
      if (typeof tg.MainButton.hide === 'function') tg.MainButton.hide();
    }
    let currentDetailItems = [];
    let currentDetailIndex = 0;
    function openDetail(it, index = 0, items = null) {
      if (currentTranslateController) {
        try { currentTranslateController.abort(); } catch (e) { }
      }
      currentTranslateController = null;
      currentTranslateKey = null;
      currentDetailItems = Array.isArray(items) ? items : getFilteredNews().slice(0, displayedCount);
      currentDetailIndex = Math.max(0, Math.min(index, currentDetailItems.length - 1));
      const root = $('#modalRoot'); root.style.display = 'flex'; root.innerHTML = '';
      const back = document.createElement('div'); back.className = 'modal-backdrop';
      const modal = document.createElement('div'); modal.className = 'modal';
      modal.innerHTML = `<button class="close">‚úñ</button><div class="modal-body"><h3 id="modalTitle"></h3><div style="color:var(--muted);font-size:12px;margin-top:6px" id="modalMeta"></div><div id="modalSummary" class="detail-text" style="color:var(--muted);font-size:13px;margin-top:8px"></div><div id="translatedBlock" class="translate-output" style="display:none"></div></div><div class="modal-actions"><button id="btnPrev" class="btn ghost small">‚óÄÔ∏é</button><button id="btnNext" class="btn ghost small">‚ñ∂Ô∏é</button><button id="btnTranslate" class="btn compact tg-hide">üåê –ü–µ—Ä–µ–≤–µ—Å—Ç–∏</button><select id="translateLang" class="lang-select compact" aria-label="–Ø–∑—ã–∫ –ø–µ—Ä–µ–≤–æ–¥–∞"><option value="ru">RU</option><option value="en">EN</option></select><button id="openLink" class="btn ghost compact tg-hide open-link-btn" type="button">–û—Ç–∫—Ä—ã—Ç—å</button></div>`;
      back.appendChild(modal); root.appendChild(back);
      back.addEventListener('click', (e) => { if (e.target === back) closeDetail(); });
      modal.querySelector('.close').addEventListener('click', closeDetail);
      const titleEl = modal.querySelector('#modalTitle');
      const metaEl = modal.querySelector('#modalMeta');
      const summaryEl = modal.querySelector('#modalSummary');
      const translatedBlock = modal.querySelector('#translatedBlock');
      const openLink = modal.querySelector('#openLink');
      const translateBtn = modal.querySelector('#btnTranslate');
      const langSel = modal.querySelector('#translateLang');
      const prevBtn = modal.querySelector('#btnPrev');
      const nextBtn = modal.querySelector('#btnNext');
      let currentText = '';
      let mainAction = 'translate';
      const tg = window.Telegram && Telegram.WebApp ? Telegram.WebApp : null;
      if (tg && typeof tg.expand === 'function') tg.expand();
      setTelegramBackButton(true);
      function updateNavButtons() {
        if (prevBtn) prevBtn.disabled = currentDetailIndex <= 0;
        if (nextBtn) nextBtn.disabled = currentDetailIndex >= currentDetailItems.length - 1;
      }
      function updateMainButton() {
        if (!tg || !tg.MainButton) return;
        const label = mainAction === 'open' ? '–û—Ç–∫—Ä—ã—Ç—å –∏—Å—Ç–æ—á–Ω–∏–∫' : '–ü–µ—Ä–µ–≤–µ—Å—Ç–∏';
        setTelegramMainButton(label, () => {
          if (mainAction === 'open') openExternalLink(currentDetailItems[currentDetailIndex].link);
          else if (translateBtn) translateBtn.click();
        });
      }
      function applyDetail(item) {
        const timeLabel = formatTime(item.date);
        if (titleEl) titleEl.textContent = item.title || '';
        if (metaEl) metaEl.textContent = `${item.source || ''}${timeLabel ? ' ¬∑ ' + timeLabel : ''}`;
        currentText = extractDetailText(item);
        if (!currentText) currentText = (item.title || '').trim();
        if (currentText.length < 60) currentText = '–¢–µ–∫—Å—Ç –≤ RSS –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –û—Ç–∫—Ä–æ–π—Ç–µ –∏—Å—Ç–æ—á–Ω–∏–∫.';
        if (summaryEl) summaryEl.textContent = currentText;
        if (openLink) { openLink.textContent = '–û—Ç–∫—Ä—ã—Ç—å –∏—Å—Ç–æ—á–Ω–∏–∫'; }
        if (translatedBlock) { translatedBlock.style.display = 'none'; translatedBlock.textContent = ''; }
        if (translateBtn) { translateBtn.textContent = 'üåê –ü–µ—Ä–µ–≤–µ—Å—Ç–∏'; translateBtn.disabled = false; }
        mainAction = currentText ? 'translate' : 'open';
        updateMainButton();
        updateNavButtons();
      }
      function goToIndex(nextIndex) {
        if (!currentDetailItems.length) return;
        currentDetailIndex = Math.max(0, Math.min(nextIndex, currentDetailItems.length - 1));
        applyDetail(currentDetailItems[currentDetailIndex]);
      }
      if (prevBtn) prevBtn.addEventListener('click', () => goToIndex(currentDetailIndex - 1));
      if (nextBtn) nextBtn.addEventListener('click', () => goToIndex(currentDetailIndex + 1));
      const bodyEl = modal.querySelector('.modal-body');
      if (bodyEl) {
        let startX = 0; let startY = 0; let tracking = false;
        bodyEl.addEventListener('touchstart', (e) => {
          if (e.touches.length !== 1) return;
          tracking = true;
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        }, { passive: true });
        bodyEl.addEventListener('touchend', (e) => {
          if (!tracking) return;
          tracking = false;
          const t = e.changedTouches[0];
          const dx = t.clientX - startX;
          const dy = t.clientY - startY;
          if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {
            if (dx < 0) goToIndex(currentDetailIndex + 1);
            else goToIndex(currentDetailIndex - 1);
          }
        }, { passive: true });
      }
      if (openLink) {
        openLink.addEventListener('click', () => {
          openExternalLink(currentDetailItems[currentDetailIndex].link);
        });
      }
      if (langSel) {
        langSel.addEventListener('change', () => {
          mainAction = 'translate';
          updateMainButton();
        });
      }
      async function translateForCurrentDetail(auto = false) {
        const target = (langSel && langSel.value) ? langSel.value : 'ru';
        if (!target || target === 'original') return;
        const text = currentText || '';
        if (!text) return;
        const key = `${currentDetailItems[currentDetailIndex].id}|${target}`;
        if (currentTranslateController) {
          try { currentTranslateController.abort(); } catch (e) { }
        }
        currentTranslateController = new AbortController();
        currentTranslateKey = key;
        const cached = translations[key];
        if (cached) {
          translatedBlock.style.display = 'block';
          translatedBlock.innerHTML = escapeHtml(cached);
          translateBtn.textContent = '–ì–æ—Ç–æ–≤–æ';
          translateBtn.disabled = true;
          setTimeout(() => { translateBtn.textContent = 'üåê –ü–µ—Ä–µ–≤–µ—Å—Ç–∏'; translateBtn.disabled = false; }, 1200);
          mainAction = 'open';
          updateMainButton();
          return;
        }
        translatedBlock.style.display = 'block';
        translatedBlock.innerHTML = escapeHtml('–ü–µ—Ä–µ–≤–æ–∂—É...');
        translateBtn.textContent = '–ü–µ—Ä–µ–≤–æ–¥...';
        translateBtn.disabled = true;
        try {
          const translated = await translateText(text, target, currentTranslateController.signal);
          if (currentTranslateKey !== key) return;
          translations[key] = translated;
          localStorage.setItem(LS_TRANSLATIONS, JSON.stringify(translations));
          translatedBlock.style.display = 'block';
          translatedBlock.innerHTML = escapeHtml(translated || '');
          translateBtn.textContent = '–ì–æ—Ç–æ–≤–æ';
          setTimeout(() => { translateBtn.textContent = 'üåê –ü–µ—Ä–µ–≤–µ—Å—Ç–∏'; translateBtn.disabled = false; }, 1200);
          mainAction = 'open';
          updateMainButton();
        } catch (err) {
          if (err && err.name === 'AbortError') return;
          console.error('translate failed', err);
          translatedBlock.style.display = 'block';
          translatedBlock.innerHTML = escapeHtml('–ü–µ—Ä–µ–≤–æ–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
          translateBtn.textContent = '–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞';
          setTimeout(() => { translateBtn.textContent = 'üåê –ü–µ—Ä–µ–≤–µ—Å—Ç–∏'; translateBtn.disabled = false; }, 1500);
          mainAction = 'translate';
          updateMainButton();
        }
      }
      if (translateBtn && translatedBlock) {
        translateBtn.addEventListener('click', async () => {
          await translateForCurrentDetail(false);
        });
      }
      applyDetail(currentDetailItems[currentDetailIndex] || it);
      const targetLang = (langSel && langSel.value) ? langSel.value : 'ru';
      const autoKey = `${currentDetailItems[currentDetailIndex].id}|${targetLang}`;
      if (targetLang !== 'original' && !translations[autoKey]) {
        translateForCurrentDetail(true);
      }
    }
    function closeDetail() {
      const root = $('#modalRoot'); root.style.display = 'none'; root.innerHTML = '';
      setTelegramBackButton(false);
      hideTelegramMainButton();
    }

    // Translation cache
    let translations = {};
    try { translations = JSON.parse(localStorage.getItem(LS_TRANSLATIONS) || '{}') || {}; } catch (e) { translations = {}; }

    // Fav
    function toggleFav(id) { if (favs.has(id)) { favs.delete(id); } else { favs.add(id); } saveFavs(); }

    async function translateText(text, target = 'ru', signal) {
      const res = await fetch(TRANSLATE_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ q: text, target }),
        signal
      });
      if (!res.ok) {
        const msg = await res.text().catch(() => '');
        throw new Error(`translate http ${res.status} ${msg}`);
      }
      const data = await res.json();
      return data.translatedText || '';
    }

    // Simple escaping
    function escapeHtml(s) { if (!s) return ''; return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }
    function decodeHtmlEntities(s) {
      if (!s) return '';
      const t = document.createElement('textarea');
      t.innerHTML = s;
      return t.value;
    }
    function decodeEntities(s) { return decodeHtmlEntities(s); }
    function stripTags(s) { return (s || '').replace(/<[^>]*>/g, ' '); }
    function normalizeSpaces(s) { return (s || '').replace(/\s+/g, ' ').trim(); }
    function extractDetailText(it) {
      const raw = (it.content || it.summary || it.description || '') + '';
      const decoded = decodeEntities(raw);
      const stripped = stripTags(decoded);
      return normalizeSpaces(stripped);
    }

    // Snow background
    const snowCanvas = document.getElementById('snowCanvas');
    const snowCtx = snowCanvas ? snowCanvas.getContext('2d') : null;
    let snowAnimId = null;
    let snowRunning = false;
    let snowLayers = [];
    let snowBaseCounts = { far: 0, mid: 0, near: 0 };
    let snowCurrentCounts = { far: 0, mid: 0, near: 0 };
    let snowLastAdjust = 0;
    let snowLastFpsCheck = 0;
    let snowFrameCount = 0;
    let snowFps = 60;
    let snowFrameSkip = 0;
    let snowW = 0;
    let snowH = 0;
    let snowDpr = 1;
    let snowOffX = 0;
    let snowOffY = 0;
    let snowTargetX = 0;
    let snowTargetY = 0;
    let snowOrientationHandler = null;

    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
    function rand(min, max) { return min + Math.random() * (max - min); }

    function resizeSnowCanvas() {
      if (!snowCanvas) return;
      snowDpr = Math.min(window.devicePixelRatio || 1, 2);
      snowW = window.innerWidth;
      snowH = window.innerHeight;
      snowCanvas.width = Math.floor(snowW * snowDpr);
      snowCanvas.height = Math.floor(snowH * snowDpr);
      snowCanvas.style.width = snowW + 'px';
      snowCanvas.style.height = snowH + 'px';
      const area = snowW * snowH;
      snowFrameSkip = area > 3000000 ? 2 : area > 2000000 ? 1 : 0;
      rebuildSnow();
    }

    function buildLayer(name, count, rMin, rMax, vMin, vMax, aMin, aMax, amp) {
      const items = [];
      for (let i = 0; i < count; i++) {
        items.push(createFlake(name, rMin, rMax, vMin, vMax, aMin, aMax, amp, true));
      }
      return { name, items, rMin, rMax, vMin, vMax, aMin, aMax, amp };
    }

    function createFlake(layer, rMin, rMax, vMin, vMax, aMin, aMax, amp, randomY) {
      return {
        layer,
        x: Math.random() * snowW,
        y: randomY ? Math.random() * snowH : -Math.random() * snowH * 0.2,
        r: rand(rMin, rMax),
        a: rand(aMin, aMax),
        vy: rand(vMin, vMax),
        vx: rand(-0.2, 0.2),
        phase: Math.random() * Math.PI * 2,
        amp
      };
    }

    function rebuildSnow() {
      if (!snowCanvas || !snowCtx) return;
      const base = (snowW * snowH) / 7000;
      snowBaseCounts = {
        far: clamp(Math.round(base * 0.55), 120, 420),
        mid: clamp(Math.round(base * 0.30), 70, 260),
        near: clamp(Math.round(base * 0.15), 30, 140)
      };
      snowCurrentCounts = { ...snowBaseCounts };
      snowLayers = [
        buildLayer('far', snowCurrentCounts.far, 0.6, 1.4, 0.25, 0.7, 0.2, 0.5, 0.4),
        buildLayer('mid', snowCurrentCounts.mid, 1.0, 2.2, 0.6, 1.3, 0.35, 0.65, 0.8),
        buildLayer('near', snowCurrentCounts.near, 1.8, 3.4, 1.0, 2.2, 0.5, 0.85, 1.4)
      ];
    }

    function resizeLayer(layer, targetCount) {
      const diff = targetCount - layer.items.length;
      if (diff > 0) {
        for (let i = 0; i < diff; i++) {
          layer.items.push(createFlake(layer.name, layer.rMin, layer.rMax, layer.vMin, layer.vMax, layer.aMin, layer.aMax, layer.amp, true));
        }
      } else if (diff < 0) {
        layer.items.length = Math.max(0, layer.items.length + diff);
      }
    }

    function adjustSnowCounts(now) {
      if (now - snowLastAdjust < 3000) return;
      snowLastAdjust = now;
      const reduce = (factor) => {
        snowCurrentCounts.far = Math.max(60, Math.round(snowCurrentCounts.far * factor));
        snowCurrentCounts.mid = Math.max(40, Math.round(snowCurrentCounts.mid * factor));
        snowCurrentCounts.near = Math.max(20, Math.round(snowCurrentCounts.near * factor));
      };
      if (snowFps < 35) {
        reduce(0.8);
      } else if (snowFps < 45) {
        reduce(0.8);
      } else if (snowFps > 55 && now - snowLastFpsCheck > 5000) {
        snowCurrentCounts.far = Math.min(snowBaseCounts.far, Math.round(snowCurrentCounts.far * 1.1));
        snowCurrentCounts.mid = Math.min(snowBaseCounts.mid, Math.round(snowCurrentCounts.mid * 1.1));
        snowCurrentCounts.near = Math.min(snowBaseCounts.near, Math.round(snowCurrentCounts.near * 1.1));
      }
      snowLayers.forEach((layer) => {
        const target = snowCurrentCounts[layer.name];
        resizeLayer(layer, target);
      });
    }

    function updateFps(now) {
      snowFrameCount += 1;
      const elapsed = now - snowLastFpsCheck;
      if (elapsed >= 2500) {
        snowFps = (snowFrameCount * 1000) / elapsed;
        snowFrameCount = 0;
        snowLastFpsCheck = now;
        adjustSnowCounts(now);
      }
    }

    function updateOrientationTarget(e) {
      const gamma = typeof e.gamma === 'number' ? e.gamma : 0;
      const beta = typeof e.beta === 'number' ? e.beta : 0;
      snowTargetX = clamp(gamma, -18, 18) * 0.9;
      snowTargetY = clamp(beta, -18, 18) * 0.6;
    }

    function enableOrientation() {
      if (!('DeviceOrientationEvent' in window)) return;
      if (snowOrientationHandler) return;
      snowOrientationHandler = (e) => updateOrientationTarget(e);
      window.addEventListener('deviceorientation', snowOrientationHandler, { passive: true });
    }

    function requestOrientationPermission() {
      if (!('DeviceOrientationEvent' in window)) return;
      const req = DeviceOrientationEvent.requestPermission;
      if (typeof req === 'function') {
        req().then((res) => { if (res === 'granted') enableOrientation(); }).catch(() => { });
      } else {
        enableOrientation();
      }
    }

    function drawSnow(now) {
      if (!snowRunning || !snowCtx || !snowCanvas) return;
      if (snowFrameSkip && (snowFrameCount % (snowFrameSkip + 1)) !== 0) {
        snowFrameCount += 1;
        snowAnimId = requestAnimationFrame(drawSnow);
        return;
      }
      updateFps(now);
      snowOffX += (snowTargetX - snowOffX) * 0.06;
      snowOffY += (snowTargetY - snowOffY) * 0.06;
      snowCtx.setTransform(1, 0, 0, 1, 0, 0);
      snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
      snowCtx.setTransform(snowDpr, 0, 0, snowDpr, snowOffX, snowOffY);
      const t = now * 0.001;
      for (const layer of snowLayers) {
        for (const f of layer.items) {
          const sway = Math.sin(t + f.phase) * f.amp;
          f.y += f.vy;
          f.x += f.vx + sway;
          if (f.y > snowH + f.r) {
            f.y = -f.r;
            f.x = Math.random() * snowW;
            f.vy = rand(layer.vMin, layer.vMax);
          }
          if (f.x < -f.r) f.x = snowW + f.r;
          if (f.x > snowW + f.r) f.x = -f.r;
          snowCtx.globalAlpha = f.a;
          snowCtx.fillStyle = 'rgba(230, 240, 255, 1)';
          snowCtx.beginPath();
          snowCtx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
          snowCtx.fill();
          if (layer.name === 'near') {
            snowCtx.globalAlpha = f.a * 0.25;
            snowCtx.beginPath();
            snowCtx.arc(f.x, f.y, f.r * 2.1, 0, Math.PI * 2);
            snowCtx.fill();
          }
        }
      }
      snowCtx.globalAlpha = 1;
      snowAnimId = requestAnimationFrame(drawSnow);
    }

    function startSnow() {
      if (!snowCanvas || !snowCtx) return;
      snowRunning = true;
      resizeSnowCanvas();
      if (snowAnimId) cancelAnimationFrame(snowAnimId);
      snowLastFpsCheck = performance.now();
      snowFrameCount = 0;
      requestOrientationPermission();
      snowAnimId = requestAnimationFrame(drawSnow);
    }

    function stopSnow() {
      snowRunning = false;
      if (snowAnimId) cancelAnimationFrame(snowAnimId);
      snowAnimId = null;
      if (snowCtx && snowCanvas) snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);
      if (snowOrientationHandler) {
        window.removeEventListener('deviceorientation', snowOrientationHandler);
        snowOrientationHandler = null;
      }
      snowTargetX = 0;
      snowTargetY = 0;
      snowOffX = 0;
      snowOffY = 0;
    }
    const DEBUG_LAYOUT = false;
    function updateViewportVars() {
      const tg = (window.Telegram && Telegram.WebApp) ? Telegram.WebApp : null;
      const safeTop = (tg && tg.safeAreaInset && typeof tg.safeAreaInset.top === 'number') ? tg.safeAreaInset.top : 0;
      const safeBottom = (tg && tg.safeAreaInset && typeof tg.safeAreaInset.bottom === 'number') ? tg.safeAreaInset.bottom : 0;
      const viewportH = (tg && typeof tg.viewportStableHeight === 'number' && tg.viewportStableHeight > 0)
        ? tg.viewportStableHeight
        : window.innerHeight;
      const isIos = !!(tg && tg.platform === 'ios');
      const topbar = isIos ? 52 : 0;
      document.documentElement.style.setProperty('--app-h', viewportH + 'px');
      document.documentElement.style.setProperty('--tg-safe-top', safeTop + 'px');
      document.documentElement.style.setProperty('--tg-safe-bottom', safeBottom + 'px');
      document.documentElement.style.setProperty('--tg-topbar', topbar + 'px');
      document.body.classList.toggle('tg-webapp', !!tg);
    }
    function updateLayoutHeights() {
      const header = document.querySelector('header');
      const bottom = document.querySelector('.bottom-bar');
      const styles = getComputedStyle(document.documentElement);
      const safeBottom = parseFloat(styles.getPropertyValue('--safe-bottom')) || 0;
      if (header) document.documentElement.style.setProperty('--header-h', header.offsetHeight + 'px');
      if (bottom) document.documentElement.style.setProperty('--bottom-h', (bottom.offsetHeight + safeBottom) + 'px');
      if (DEBUG_LAYOUT) {
        const safeTop = parseFloat(styles.getPropertyValue('--safe-top')) || 0;
        const appH = styles.getPropertyValue('--app-h');
        console.log('[layout]', {
          appH,
          safeTop,
          safeBottom,
          headerH: header ? header.offsetHeight : 0,
          bottomH: bottom ? bottom.offsetHeight : 0
        });
      }
    }

    // Theme & UI init
    function applyTheme() { const saved = localStorage.getItem(LS_THEME); if (saved === 'dark') { document.documentElement.style.setProperty('--bg', '#071022'); } else if (saved === 'light') { document.documentElement.style.setProperty('--bg', '#f6f7fb'); document.documentElement.style.setProperty('--text', '#071022'); } }
    function applyTelegramTheme() {
      const tg = window.Telegram && Telegram.WebApp ? Telegram.WebApp : null;
      if (!tg || !tg.themeParams) return;
      const p = tg.themeParams;
      if (p.bg_color) document.documentElement.style.setProperty('--bg', p.bg_color);
      if (p.text_color) document.documentElement.style.setProperty('--text', p.text_color);
      if (p.button_color) document.documentElement.style.setProperty('--accent', p.button_color);
      if (p.secondary_bg_color) document.documentElement.style.setProperty('--secondary', p.secondary_bg_color);
    }

    // Bind UI
    document.getElementById('btnLoad').addEventListener('click', () => { const v = document.getElementById('inputFeed').value.trim(); if (v) { fetchUrl = v; loadNews(fetchUrl); } else loadNews(); });
    const bgToggleBtn = document.getElementById('bgToggle'); if (bgToggleBtn) bgToggleBtn.addEventListener('click', () => { const cur = localStorage.getItem(LS_BG) === '1'; localStorage.setItem(LS_BG, cur ? '0' : '1'); updateBgToggle(); });
    const favFilterBtn = document.getElementById('btnFavFilter');
    if (favFilterBtn) favFilterBtn.addEventListener('click', () => {
      favFilterOn = !favFilterOn;
      favFilterBtn.classList.toggle('active', favFilterOn);
      favFilterBtn.setAttribute('aria-pressed', favFilterOn ? 'true' : 'false');
      favFilterBtn.classList.toggle('iconBtn', true);
      displayedCount = PAGE_SIZE;
      renderNews();
    });
    const sourceBtn = document.getElementById('sourceBtn');
    const sourceBackdrop = document.getElementById('sourceMenuBackdrop');
    if (sourceBtn) sourceBtn.addEventListener('click', (e) => { e.stopPropagation(); openSourceMenu(); });
    if (sourceBackdrop) sourceBackdrop.addEventListener('click', closeSourceMenu);
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeSourceMenu(); });
    // Load more button
    const loadMoreBtn = document.getElementById('btnLoadMore'); if (loadMoreBtn) { loadMoreBtn.addEventListener('click', () => { const list = getFilteredNews(); if (!list || !list.length) return; displayedCount = displayedCount + PAGE_SIZE; renderNews(); }); }

    function updateBgToggle() {
      const on = localStorage.getItem(LS_BG) !== '0';
      const el = document.getElementById('bgToggle');
      const label = document.getElementById('bgLabel');
      if (el) el.classList.toggle('on', on);
      if (label) label.textContent = on ? '–§–æ–Ω: –í–∫–ª' : '–§–æ–Ω: –í—ã–∫–ª';
      document.body.classList.toggle('bg-on', on);
      if (on) startSnow(); else stopSnow();
    }
    let lastLocation = null;
    function onLocationAvailable(loc) {
      // hook for future proximity-based ranking
    }
    function initLocation() {
      const tg = window.Telegram && Telegram.WebApp ? Telegram.WebApp : null;
      const lm = tg && tg.LocationManager ? tg.LocationManager : null;
      if (!lm) return;
      try {
        const saveLoc = (loc) => {
          if (!loc) return;
          lastLocation = loc;
          try { localStorage.setItem('tg_last_location', JSON.stringify(loc)); } catch (e) { }
          onLocationAvailable(loc);
        };
        if (typeof lm.requestPermission === 'function') {
          const res = lm.requestPermission();
          if (res && typeof res.then === 'function') {
            res.then((granted) => {
              if (!granted) return;
              if (typeof lm.getLocation === 'function') {
                const r = lm.getLocation();
                if (r && typeof r.then === 'function') r.then(saveLoc);
              }
            }).catch(() => { });
          }
        } else if (typeof lm.getLocation === 'function') {
          const r = lm.getLocation();
          if (r && typeof r.then === 'function') r.then(saveLoc);
        }
      } catch (e) { }
    }
    function updateAdvancedVisibility() {
      const adv = document.getElementById('feedAdvanced');
      const btn = document.getElementById('btnToggleAdvanced');
      if (!adv) return;
      const isMobile = window.matchMedia('(max-width: 520px)').matches;
      const saved = localStorage.getItem(LS_UI_ADVANCED) === '1';
      adv.classList.toggle('show', saved);
      if (btn) {
        btn.textContent = saved ? '–ü–æ–∫–∞–∑–∞–Ω–∞' : '–°–∫—Ä—ã—Ç–∞';
        btn.setAttribute('aria-pressed', saved ? 'true' : 'false');
      }
      updateMobileHeaderState(isMobile);
      updateLayoutHeights();
    }
    function setAdvanced(open) {
      localStorage.setItem(LS_UI_ADVANCED, open ? '1' : '0');
      updateAdvancedVisibility();
    }
    const menuBtn = document.getElementById('btnMenu');
    const menuPopover = document.getElementById('menuPopover');
    const menuBackdrop = document.getElementById('menuBackdrop');
    function closeMenu() {
      if (!menuPopover || !menuBackdrop) return;
      menuPopover.style.display = 'none';
      menuPopover.setAttribute('aria-hidden', 'true');
      menuBackdrop.style.display = 'none';
    }
    function positionMenu() {
      if (!menuBtn || !menuPopover) return;
      const rect = menuBtn.getBoundingClientRect();
      const pad = 8;
      const width = menuPopover.offsetWidth || 200;
      let left = rect.right - width;
      if (left < pad) left = pad;
      let top = rect.bottom + pad;
      if (top < pad) top = pad;
      menuPopover.style.left = `${left}px`;
      menuPopover.style.top = `${top}px`;
    }
    function toggleMenu() {
      if (!menuPopover || !menuBackdrop) return;
      const isOpen = menuPopover.style.display === 'block';
      if (isOpen) { closeMenu(); return; }
      menuPopover.style.display = 'block';
      menuPopover.setAttribute('aria-hidden', 'false');
      menuBackdrop.style.display = 'block';
      positionMenu();
    }
    if (menuBtn) menuBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(); });
    if (menuBackdrop) menuBackdrop.addEventListener('click', closeMenu);
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeMenu(); });
    const advBtn = document.getElementById('btnToggleAdvanced');
    if (advBtn) advBtn.addEventListener('click', () => {
      const adv = document.getElementById('feedAdvanced');
      const isOpen = adv && adv.classList.contains('show');
      setAdvanced(!isOpen);
    });

    function updateMobileHeaderState(isMobile) {
    }

    // Boot
    function handleViewportChange() {
      resizeSnowCanvas();
      if (snowRunning) createSnow();
      updateViewportVars();
      updateLayoutHeights();
      updateAdvancedVisibility();
      if (menuPopover && menuPopover.style.display === 'block') positionMenu();
      const sourceMenu = document.getElementById('sourceMenu');
      if (sourceMenu && sourceMenu.style.display === 'block') positionSourceMenu();
    }
    window.addEventListener('resize', handleViewportChange);
    window.addEventListener('orientationchange', handleViewportChange);
    window.addEventListener('DOMContentLoaded', () => {
      updateViewportVars();
    });
    window.addEventListener('load', () => {
      updateViewportVars();
      if (window.Telegram && Telegram.WebApp && typeof Telegram.WebApp.onEvent === 'function') {
        Telegram.WebApp.onEvent('viewportChanged', handleViewportChange);
      }
      updateLayoutHeights();
      const tg = window.Telegram && Telegram.WebApp ? Telegram.WebApp : null;
      if (tg && typeof tg.expand === 'function') tg.expand();
      if (tg && typeof tg.onEvent === 'function') tg.onEvent('themeChanged', applyTelegramTheme);
      if (tg) applyTelegramTheme(); else applyTheme();
      initLocation();
      // populate source selector and restore selection
      try { loadSources(); } catch (e) { console.warn('loadSources failed', e); }
      // restore cached data
      try { const cached = JSON.parse(localStorage.getItem(LS_LAST) || 'null'); if (cached && cached.length) { news = cached; } } catch (e) { }
      try { favs = new Set(JSON.parse(localStorage.getItem(LS_FAV) || '[]')); } catch (e) { favs = new Set(); }
      updateAdvancedVisibility();
      // if a saved source exists, load it; otherwise show default fetchUrl
      const savedSrc = localStorage.getItem(LS_SRC);
      if (savedSrc) { document.getElementById('inputFeed').value = (SOURCES.find(s => s.id === savedSrc) || {}).url || fetchUrl; renderNews(); updateBgToggle(); loadNewsById(savedSrc); }
      else { document.getElementById('inputFeed').value = fetchUrl; renderNews(); updateBgToggle(); loadNews(); }
    });

    // Global error handlers for debugging
    window.addEventListener('error', (e) => { console.error('Global error', e.error || e); });
    window.addEventListener('unhandledrejection', (e) => { console.error('Unhandled rejection', e.reason); });
  </script>
</body>

</html>
